---
title: "[심화 파이썬] 에피소드2: 튜플"
excerpt: ""

categories:
  - python
tags:
  - [python, tuple, "fluent python", array, 파이썬, 튜플]

permalink: /python/2

toc: true
toc_sticky: true

date: 2024-10-03
last_modified_at: 2024-10-03
---

튜플의 역할에 대해 자세히 알아보자.

___

**차례**

- [레코드로서의 튜플](#레코드로서의-튜플)
- [Immutable List로서의 튜플](#immutable-list로서의-튜플)
- [결론](#결론)

___

## 레코드로서의 튜플

튜플은 리스트와 달리 한 번 생성되면 수정할 수 없다. 이 특징을 가리켜 튜플이 "immutable list"라고 한다. 이렇게 수정할 수 없는 특징을 이용해 튜플을 필드 이름이 없는 레코드로서 사용할 수 있다. 예를 들어 보자.

```python
traveler_ids=[('USA', '1234'), ('KOR', '5678'), ('JPN', '5252')]
```

위 코드의 traveler_ids는 traveler_id의 리스트이다. traveler_id들은 각각 튜플로 되어 있고 이 튜플의 첫 번째 원소는 국가 코드를, 두 번째 원소는 여행자 코드를 기록하고 있다. 이와 같이 튜플은 여러 구성 요소로 이루어져 있는 레코드로서 사용할 수 있다. 

리스트보다 튜플이 레코드로 사용하기 적합한 이유는 수정이 불가능하기 때문이다. 리스트를 레코드로 사용한다고 해 보자. 그런데 실수로 그 리스트를 정렬(sort)해 버렸다. 그러면 구성 요소 간의 순서가 뒤죽박죽이 되어 의미가 없는 레코드가 되어 버릴 것이다. 튜플은 이런 일이 일어나지 않는다.

또한 뒤에서 자세히 다루겠지만 튜플이기에 unpacking을 사용할 수 있다. 다음과 같이 말이다.

```python
for country, _ in traveler_ids:
    print(country)
```

> _는 더미 변수(dummy variable)로서, 두 번째 원소는 사용하지 않으므로 _에 할당한다.

## Immutable List로서의 튜플

물론 튜플은 Immutable List이기도 하다. 여기에는 두 가지 장점이 있다.

- **명확성**: 코드에서 튜플을 보면, 그 튜플의 길이가 변하지 않을 것임을 알 수 있다.
- **성능**: 같은 길이일 때 튜플이 리스트보다 공간을 덜 차지하고, *'파이썬'*이 최적화하기 쉬워진다.

하지만 이 Immutability는 튜플 그 자체에 대해서만 성립하는 것이다. 튜플 안에 리스트가 있으면 그 리스트는 변경할 수 있다. 예를 들어 보자.

```python
a=(1, 2, [3, 4, 5])
a[-1].append(6)
print(a)
```

**Output**: `(1, 2, [3, 4, 5, 6])`

이렇게 튜플에 mutable item이 있으면 버그가 일어나기 쉽다. 뒤의 에피소드들에서 살펴보겠지만 객체가 hashable하려면 그 객체의 값이 절대 변할 수 없어야 한다. mutable item을 포함한 튜플은 값이 변할 수 있으므로 hashable하지 않다. 이렇게 hashable하지 않은 튜플들은 딕셔너리의 키로 사용되거나 set의 원소로 사용될 수 없다.

하지만 여전히 튜플은 immutable list로서 리스트에 비해 성능 이점이 있기에 널리 사용된다.

## 결론

이번 에피소드에서는 튜플의 역할에 대해 자세히 알아보았다. 다음 에피소드에서는 'Unpacking'에 대해 자세히 알아보자.

[다음 에피소드로](/python/3)