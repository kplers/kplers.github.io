---
title: "[자바스크립트] 에피소드1: 변수"
excerpt: ""

categories:
  - js
tags:
  - [javascript, 자바스크립트]

permalink: /js/1

toc: true
toc_sticky: true

date: 2024-11-03
last_modified_at: 2024-11-04
---

JS 첫 에피소드에서는 자바스크립트의 변수에 대해 알아보자.

___

**차례**

- [선언](#선언)
- [변수 호이스팅(Variable Hoisting)](#변수-호이스팅variable-hoisting)
- [할당](#할당)
- [재할당](#재할당)
- [식별자 네이밍 규칙](#식별자-네이밍-규칙)


___

## 선언

자바스크립트의 변수는 var, let, const로 선언할 수 있다. let, const는 ES6에서 도입되었으며 그 전에는 var이 유일했다.

```js
var score;
```

아직 할당하지 않은 변수는 자바스크립트 엔진이 undefined라는 값으로 암묵적으로 할당하여 초기화한다. 즉, 초기화하지 않은 변수를 참조할 때 쓰레기 값이 나오는 문제가 없다.

## 변수 호이스팅(Variable Hoisting)

다음과 같은 코드를 생각해보자.

```js
console.log(score);
var score;
```

Python과 같은 언어였다면 오류가 났을 것이다. 하지만 JS에서 변수의 선언은 런타임이 아닌 그 이전 단계에서 실행된다. 즉, 마치 변수 선언문이 코드의 맨 위로 끌어올려진 것만 같다. 

이러한 특징을 **변수 호이스팅**이라 한다.

## 할당

다른 언어와 마찬가지로 다음과 같이 할당한다.

```JS
var score;
score=74; // 할당
```

변수의 선언과 할당을 동시에 할 수도 있다.

```JS
var score=74; // 선언과 할당
```

다른 점이라면 위에서 언급한 변수 호이스팅 때문에 선언과 할당을 동시에 하더라도, 실제 실행은 선언이 런타임 이전에 먼저 되고, 할당이 런타임 때 일어난다는 점이다.

예를 들어,

```JS
console.log(score);
var score = 74;
console.log(score);
```

앞서 언급했다시피 score라는 변수의 선언은 런타임 이전에 이루어지므로 첫 번째 log에서도 오류가 일어나지 않는다. 하지만 변수의 할당\(자바스크립트 엔진이 암묵적으로 undefined로 할당하는 것 말고\)은 런타임에 이루어진다. 따라서 첫 번째 log에서는 아직 할당 전이므로 undefined가 출력되고, 두 번째 log에서는 할당 후이므로 74가 출력될 것이다.

## 재할당

자바스크립트의 var 변수는 값을 재할당할 수 있다.

```JS
var score=74;
score=96;
```

이렇게 재할당할 수 있는 것이 당연한 것은 아니다. 재할당할 수 없는 변수도 있는데, 이를 상수라고 한다.

ES6에서 도입된 const를 사용해 변수를 선언하면 상수가 된다.

```JS
const foo=10;
foo=100; // Error!
```

## 식별자 네이밍 규칙

식별자\(어떤 값을 구별해서 식별해낼 수 있는 고유한 이름\)는 다음 규칙을 준수해야 한다.

1. 특수문자가 아닌 문자, 숫자, _, $를 포함할 수 있다.
2. 숫자로 시작할 수 없다.
3. 예약어는 사용할 수 없다.

예약어는 다음과 같다.

![alt text](/assets/images/JS_reserved.png)

자바스크립트에도 네이밍 컨벤션이 있다. 보통은 변수나 함수의 이름은 카멜케이스, 생성자 함수나 클래스의 이름에는 파스칼 케이스를 사용한다.

카멜케이스는 firstClass, 파스칼 케이스는 FirstClass와 같이 쓰는 것이다.


[다음 에피소드로](/js/2)
